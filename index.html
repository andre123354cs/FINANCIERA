<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROCESOS YESBPO | Automatizaci√≥n de Datos Optimizada</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body { background-color: #f4f7f6; display: flex; flex-direction: column; min-height: 100vh; }
        .container { max-width: 1400px; margin-top: 20px; background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex-grow: 1; }
        .section-panel { padding: 15px; border: 1px solid #e0e0e0; border-radius: 0.25rem; margin-bottom: 20px; }
        .step-divider { border-top: 4px solid #0d6efd; margin-top: 30px; margin-bottom: 30px; padding-top: 15px; }
        h1 { color: #0d6efd; font-weight: 700; margin-bottom: 30px; }
        .section-title { font-size: 1.5rem; color: #495057; border-bottom: 2px solid #0d6efd; padding-bottom: 10px; margin-bottom: 20px; }
        /* Estilos para los botones de navegaci√≥n (M√≥dulos) */
        .module-nav button {
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 1.1rem;
            border-radius: 0.5rem;
            border: 2px solid #0d6efd;
            background-color: #ffffff;
            color: #0d6efd;
        }
        .module-nav button.active {
            background-color: #0d6efd;
            color: #ffffff;
            box-shadow: 0 4px 8px rgba(13, 110, 253, 0.5);
        }
        .module-nav button:hover:not(.active) {
            background-color: #e9f0ff;
            color: #0b5ed7;
        }
        /* Clases para ocultar elementos de configuraci√≥n y filtros */
        .hidden-preview { display: none !important; }
        .hidden-filters select, .hidden-filters button { display: none !important; } 
        .footer { padding: 15px 0; background-color: #e9ecef; color: #6c757d; text-align: center; margin-top: 20px; font-size: 0.85rem; }
    </style>
</head>
<body onload="loadCacheOnStart()">

<div class="container">
    <h1 class="text-center">PROCESOS YESBPO</h1>
    
    <div class="d-flex flex-wrap justify-content-center gap-3 mb-4 module-nav" role="tablist">
        <button class="btn px-4 py-2 active" id="comfama-tab" data-bs-toggle="tab" data-bs-target="#comfama" type="button" role="tab" aria-controls="comfama" aria-selected="true">
            Comfama Financiera üè¶
        </button>
        <button class="btn px-4 py-2" id="azzorti-tab" data-bs-toggle="tab" data-bs-target="#azzorti" type="button" role="tab" aria-controls="azzorti" aria-selected="false">
            Azzorti üëï
        </button>
        <button class="btn px-4 py-2" id="otra-tab" data-bs-toggle="tab" data-bs-target="#otra" type="button" role="tab" aria-controls="otra" aria-selected="false">
            Otro M√≥dulo ‚ú®
        </button>
    </div>

    <div class="tab-content" id="processTabsContent">
        <div class="tab-pane fade show active" id="comfama" role="tabpanel" aria-labelledby="comfama-tab">
            <div class="alert alert-warning py-2 mb-4" id="cacheStatus" style="display:none;"></div>

            <div id="pagosSection" class="section-panel">
                <div class="section-title text-success">1. Carpeta de Pagos (Consolidaci√≥n y Cach√©)</div>
                
                <p class="fw-bold">1.1 Carga de Carpeta de Pagos</p>
                <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="pagosFolderInput">
                <div class="alert alert-info py-1" id="pagosStatus">Cargue la **Carpeta de Pagos** (si desea actualizar la data) o cargue directamente el Paso 2.</div>
                
                <div class="alert alert-light mt-2 py-1" id="pagosProcessStatus" style="display:none;"></div>
                
                <div class="hidden-filters">
                    <select id="col1Select" class="form-select"></select>
                    <select id="col2Select" class="form-select"></select>
                    <select id="col3Select" class="form-select"></select>
                    <select id="col4Select" class="form-select"></select>
                    <button id="executeMerge">REALIZAR CRUCE DE DATOS (LEFT JOIN)</button>
                </div>
            </div>
            
            <div class="section-panel step-divider">
                <div class="section-title">2. Carpeta de Asignaciones (Limpieza y Cruce Autom√°tico)</div>
                
                <p class="fw-bold">2.1 Carga de Carpeta de Asignaciones (Principal)</p>
                <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="folderInput">
                <div class="alert alert-info py-1" id="anexoStatus">Cargue la **Carpeta de Asignaciones** para iniciar el proceso de Limpieza y Cruce.</div>
                
                <p class="fw-bold mt-4">2.2 Proceso Autom√°tico (Limpieza y Cruce)</p>
                
                <div class="alert alert-light mt-2 py-1" id="dedupeStatus" style="display:none;"></div>
                
                <div id="preProcessConfig" class="hidden-filters">
                    <select id="docColSelect" class="form-select"></select>
                    <select id="secAggColSelect" class="form-select"></select>
                    <select id="minColSelect" class="form-select"></select>
                    <select id="maxColSelect" class="form-select"></select>
                    <select id="dupCol1Select" class="form-select"></select>
                    <select id="dupCol2Select" class="form-select"></select>
                    <select id="dupCol3Select" class="form-select"></select>
                </div>
                
                <div class="d-grid gap-2 d-md-flex justify-content-md-start mt-4">
                    <button class="btn btn-primary btn-lg" onclick="downloadFile(mergedData, 'resultado_cruce_final.csv', '|');" id="downloadMergeBtn" style="display:none;">
                        Descargar Data
                    </button>
                    <button id="downloadAnexoBtn" style="display:none;"></button>
                </div>
                
            </div>
        </div>

        <div class="tab-pane fade" id="azzorti" role="tabpanel" aria-labelledby="azzorti-tab">
            <div class="alert alert-secondary text-center py-4">
                <h4>Azzorti (M√≥dulo en Desarrollo)</h4>
                <p>Aqu√≠ se implementar√°n los procesos de automatizaci√≥n espec√≠ficos para Azzorti.</p>
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Cargando...</span>
                </div>
            </div>
        </div>

        <div class="tab-pane fade" id="otra" role="tabpanel" aria-labelledby="otra-tab">
            <div class="alert alert-secondary text-center py-4">
                <h4>Otro M√≥dulo (En Construcci√≥n)</h4>
                <p>Este espacio est√° reservado para futuros procesos de automatizaci√≥n.</p>
                <div class="spinner-border text-success" role="status">
                    <span class="visually-hidden">Cargando...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<footer class="footer">
    Autor√≠a: Andr√©s Vanegas - √Årea de Inteligencia YesBPO
</footer>

<script>
    // Variables globales
    let db;¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†
    const CACHE_KEY_PAGOS = 'processedPagosData';

    let dataFilePagos = null;¬† ¬†¬†
    let processedDataAsignaciones = null;¬†
    let mergedData = null;¬† ¬† ¬† ¬†

    // Elementos del DOM
    const folderInput = document.getElementById('folderInput');
    const anexoStatus = document.getElementById('anexoStatus');
    const dedupeStatus = document.getElementById('dedupeStatus');
    const downloadMergeBtn = document.getElementById('downloadMergeBtn');
    
    const pagosFolderInput = document.getElementById('pagosFolderInput');
    const pagosStatus = document.getElementById('pagosStatus');
    const pagosProcessStatus = document.getElementById('pagosProcessStatus');
    
    // Contadores para el progreso
    let processedRowsCount = 0; 
    let totalRowsCount = 0; 

    // Nombres de Columnas (CONSTANTES)
    const COL_DOC_PRIN = 'Numero Documento';
    const COL_MES_PRIN = 'Mes data';
    const COL_FECHA_PRIN = 'Nombre del archivo'; // Usamos este para guardar la fecha del archivo
    const COL_ANIO_PRIN = 'A√±o';
    const COL_DOC_PAGOS = 'Numero de Documento';
    const COL_MES_PAGOS = 'MES';
    const COL_FECHA_MAX_PAGOS = 'Fecha_Movimiento_Maxima';
    const COL_VALOR_PAGADO = 'Suma_Valor_Pagado';
    const COL_VALOR_PAGADO_RAW = 'Valor Pagado';¬†
    const COL_FECHA_MOV = 'Fecha Movimiento';¬†

    // ----------------------------------------------------------------------
    // --- IndexedDB y Utilidades (Sin cambios funcionales mayores) ---
    // ----------------------------------------------------------------------

    function initDB() { /* ... (Mantener la funci√≥n de IndexedDB) ... */
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) {
                console.warn('IndexedDB no soportado. Cach√© deshabilitado.');
                return resolve(null);
            }
            const request = window.indexedDB.open("ComfamaCacheDB", 1);
            request.onerror = (event) => {
                console.error(`Error al abrir la base de datos: ${event.target.errorCode}`, event.target.error);
                reject(event.target.error);
            };
            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };
            request.onupgradeneeded = (event) => {
                const dbInstance = event.target.result;
                if (!dbInstance.objectStoreNames.contains('dataStore')) {
                    dbInstance.createObjectStore('dataStore', { keyPath: 'key' });
                }
            };
        });
    }

    function saveDataToCache(key, data) { /* ... (Mantener la funci√≥n de IndexedDB) ... */
        if (!db) return Promise.resolve();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(['dataStore'], 'readwrite');
            const store = transaction.objectStore('dataStore');
            const dataToStore = { key: key, data: data, timestamp: new Date() };
            const request = store.put(dataToStore);
            request.onsuccess = () => resolve();
            request.onerror = (event) => {
                console.error('Error al guardar en cach√©.', event.target.error);
                reject(event.target.error);
            };
        });
    }

    function loadDataFromCache(key) { /* ... (Mantener la funci√≥n de IndexedDB) ... */
        if (!db) return Promise.resolve(null);
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(['dataStore'], 'readonly');
            const store = transaction.objectStore('dataStore');
            const request = store.get(key);
            request.onsuccess = () => {
                const result = request.result;
                if (result && result.data && result.data.length > 0) {
                    dataFilePagos = result.data;
                    pagosStatus.textContent = `‚úÖ Data de Pagos (Cach√©) cargada. Filas: ${dataFilePagos.length}. Lista para usar.`;
                    pagosStatus.className = 'alert alert-success py-1';
                    resolve(dataFilePagos);
                } else {
                    pagosStatus.textContent = '‚ÑπÔ∏è Data de Pagos no encontrada en cach√©. Cargue la Carpeta de Pagos (Paso 1).';
                    pagosStatus.className = 'alert alert-info py-1';
                    resolve(null);
                }
            };
            request.onerror = (event) => {
                console.error('Error al cargar el cach√©.', event.target.error);
                resolve(null);
            };
        });
    }

    async function loadCacheOnStart() {
        try {
            await initDB();
            await loadDataFromCache(CACHE_KEY_PAGOS);
        } catch (e) {
            console.error('Fallo grave al inicializar la base de datos de cach√©.', e);
        }
    }
    
    function determineDelimiter(fileChunk) {
        if (fileChunk.includes('|')) return '|';
        if (fileChunk.includes(';')) return ';';
        return ',';
    }

    function downloadFile(data, filename, delimiter) { /* ... (Mantener la funci√≥n de descarga) ... */
        if (!data) {
            alert('No hay datos disponibles para descargar.');
            return;
        }
        const finalData = Array.isArray(data) ? data : data.data;
        const csv = Papa.unparse(finalData, { delimiter: delimiter, header: true });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    const parseDate = (dateString) => { /* ... (Mantener la funci√≥n de parseo de fecha) ... */
        if (!dateString) return new Date(0);¬†
        let dateParts = dateString.match(/(\d{1,2})[-./](\d{1,2})[-./](\d{4})/);
        if (dateParts) {
            const d = new Date(parseInt(dateParts[3]), parseInt(dateParts[2]) - 1, parseInt(dateParts[1]));
            if (!isNaN(d.getTime())) return d;
        }¬†
        dateParts = dateString.match(/(\d{4})-(\d{2})-(\d{2})/);
           if (dateParts) {
            const d = new Date(parseInt(dateParts[1]), parseInt(dateParts[2]) - 1, parseInt(dateParts[3]));
            if (!isNaN(d.getTime())) return d;
        }¬†
        return new Date(0);¬†
    };
    
    const formatDateToDDMMYYYY = (date) => { /* ... (Mantener la funci√≥n de formateo de fecha) ... */
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');¬†
        const year = d.getFullYear();
        return `${day}/${month}/${year}`;
    };

    function getIntegerValue(value) { /* ... (Mantener la funci√≥n de valor entero) ... */
        if (value === null || value === undefined) return 0;
        let strValue = String(value).trim();
        const splitIndex = strValue.indexOf('.');
        let integerPart = (splitIndex !== -1) ? strValue.substring(0, splitIndex) : strValue;
        integerPart = integerPart.replace(/[^0-9-]/g, '');¬†
        return parseInt(integerPart, 10) || 0;
    }

    // ----------------------------------------------------------------------
    // --- L√≥gica del Cruce y Procesamiento de Pagos (Streaming & Workers) ---
    // ----------------------------------------------------------------------

    function executeMerge() {
        if (!processedDataAsignaciones || !dataFilePagos) {
            return;
        }

        const key1_A = COL_DOC_PRIN;
        const key1_B = COL_DOC_PAGOS;
        const key2_A = COL_MES_PRIN;
        const key2_B = COL_MES_PAGOS;
        
        dedupeStatus.textContent = 'üöÄ CRUCE DE DATOS AUTOM√ÅTICO EN CURSO... Por favor, espere.';
        dedupeStatus.className = 'alert alert-warning py-1';
        downloadMergeBtn.style.display = 'none';¬†

        // Usamos setTimeout para que el navegador actualice la UI
        setTimeout(() => {
            
            const data1 = processedDataAsignaciones;
            const data2 = dataFilePagos;
            
            const headers2 = [COL_FECHA_MAX_PAGOS, COL_VALOR_PAGADO];

            // 1. Crear el mapa de b√∫squeda (data2 - Pagos)
            const map2 = new Map();
            data2.forEach(row => {
                const keyValue = `${String(row[key1_B] || '').trim()}|${String(row[key2_B] || '').trim()}`;
                
                if (keyValue) {
                    const rowData = {};
                    headers2.forEach(field => rowData[field] = row[field]);
                    map2.set(keyValue, rowData);
                }
            });
            
            const mergedResults = [];
            
            data1.forEach(row1 => {
                const searchKey = `${String(row1[key1_A] || '').trim()}|${String(row1[key2_A] || '').trim()}`;

                const row2Data = map2.get(searchKey) || {};
                
                const newRow = { ...row1 };¬†
                let isMatch = Object.keys(row2Data).length > 0;
                
                for (const field of headers2) {
                    newRow[field] = isMatch ? row2Data[field] : '';¬†
                }
                mergedResults.push(newRow);
            });

            mergedData = mergedResults;
            
            if (mergedData.length > 0) {
                dedupeStatus.textContent = `‚úÖ **PROCESO FINALIZADO**. Data lista para descargar.`;
                dedupeStatus.className = 'alert alert-success py-1';
                downloadMergeBtn.style.display = 'block';¬†
            } else {
                dedupeStatus.textContent = `‚ö†Ô∏è Error: El cruce no gener√≥ resultados v√°lidos. Revise la Carpeta de Pagos y la Carpeta de Asignaciones.`;
                dedupeStatus.className = 'alert alert-danger py-1';
            }
            
            // Liberamos la memoria de la data de asignaciones temporal
            processedDataAsignaciones = null;¬†

        }, 50);¬†
    }

    // MAPA DE PAGOS: Se construye directamente durante el streaming para optimizar
    const aggregatedPagosMap = new Map(); 

    async function processPagosFile(file) {
        return new Promise((resolve, reject) => {
            // 1. Determinar el delimitador de forma segura
            const reader = new FileReader();
            reader.onload = function(event) {
                const chunk = event.target.result.substring(0, 1024);
                const delimiter = determineDelimiter(chunk);

                // 2. Iniciar el parsing con Web Worker y Streaming
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    delimiter: delimiter,
                    worker: true, // ¬°Usa un Web Worker!
                    step: (results, parser) => {
                        // Procesamiento por cada chunk (fila)
                        const row = results.data[0];
                        if (results.errors.length > 0) return;

                        const valorPagadoEntero = getIntegerValue(row[COL_VALOR_PAGADO_RAW]);
                        const docValue = String(row[COL_DOC_PAGOS] || '').trim();
                        const fechaMovStr = String(row[COL_FECHA_MOV] || '').trim();
                        
                        if (!docValue || !fechaMovStr) return;¬†

                        const fechaMov = parseDate(fechaMovStr);
                        if (isNaN(fechaMov.getTime())) return;

                        const mes = String(fechaMov.getMonth() + 1);
                        const groupKey = `${docValue}|${mes}`;
                        
                        // Agregaci√≥n en memoria (Mapa)
                        if (!aggregatedPagosMap.has(groupKey)) {
                            aggregatedPagosMap.set(groupKey, {
                                [COL_DOC_PAGOS]: docValue,
                                [COL_MES_PAGOS]: mes,
                                [COL_FECHA_MOV]: fechaMov,¬†
                                [COL_VALOR_PAGADO]: valorPagadoEntero,¬†
                            });
                        } else {
                            const data = aggregatedPagosMap.get(groupKey);
                            if (fechaMov.getTime() > data[COL_FECHA_MOV].getTime()) {
                                data[COL_FECHA_MOV] = fechaMov;
                            }
                            data[COL_VALOR_PAGADO] += valorPagadoEntero;
                        }
                        
                        totalRowsCount++;
                        if (totalRowsCount % 5000 === 0) {
                             pagosProcessStatus.textContent = `‚öôÔ∏è Agregando data de Pagos... Filas procesadas: ${totalRowsCount.toLocaleString()}.`;
                        }

                    },
                    complete: () => {
                        resolve();
                    },
                    error: (error) => {
                        console.error(`Error de PapaParse en ${file.name}:`, error);
                        reject(error);
                    }
                });
            };
            // Leer solo un trozo para determinar el delimitador
            reader.readAsText(file.slice(0, 1024 * 10), 'UTF-8');
        });
    }

    async function executePagosProcess(files) {
        pagosProcessStatus.textContent = `‚öôÔ∏è Iniciando Consolidaci√≥n de ${files.length} archivos de Pagos...`;
        pagosProcessStatus.className = 'alert alert-warning py-1';
        pagosProcessStatus.style.display = 'block';

        // 1. Reiniciar el mapa y el contador
        aggregatedPagosMap.clear();
        totalRowsCount = 0;

        for (const file of files) {
            if (!file.name.toLowerCase().endsWith('.csv') && !file.name.toLowerCase().endsWith('.txt')) continue;
            try {
                // Procesar cada archivo en streaming
                await processPagosFile(file);
            } catch (e) {
                // El error ya se maneja dentro de processPagosFile
            }
        }
        
        if (aggregatedPagosMap.size === 0) {
            pagosProcessStatus.textContent = '‚ùå No se encontraron datos v√°lidos en la Carpeta de Pagos.';
            pagosProcessStatus.className = 'alert alert-danger py-1';
            return;
        }

        pagosProcessStatus.textContent = `‚öôÔ∏è Finalizando y transformando ${aggregatedPagosMap.size.toLocaleString()} agrupaciones...`;
        
        const finalDataPagos = Array.from(aggregatedPagosMap.values()).map(data => {
            return {
                [COL_DOC_PAGOS]: data[COL_DOC_PAGOS],
                [COL_MES_PAGOS]: data[COL_MES_PAGOS],
                // El formato de fecha se hace aqu√≠, despu√©s de la agregaci√≥n
                [COL_FECHA_MAX_PAGOS]: formatDateToDDMMYYYY(data[COL_FECHA_MOV]),¬†
                [COL_VALOR_PAGADO]: data[COL_VALOR_PAGADO],
            };
        });
        
        dataFilePagos = finalDataPagos;

        // Guardado en Cach√©
        await saveDataToCache(CACHE_KEY_PAGOS, dataFilePagos);

        pagosProcessStatus.textContent = `‚úÖ Consolidaci√≥n y Transformaci√≥n de Pagos Completada. Filas finales: ${dataFilePagos.length.toLocaleString()}.`;
        pagosProcessStatus.className = 'alert alert-success py-1';
        pagosStatus.textContent = `Data de Pagos lista. Ahora, cargue la Carpeta de Asignaciones (Paso 2).`;
        pagosStatus.className = 'alert alert-success py-1';

        // Si la data de Asignaciones ya est√° lista, iniciar el cruce
        if (processedDataAsignaciones) {
            executeMerge();
        }
    }
    
    // ----------------------------------------------------------------------
    // --- L√≥gica del Procesamiento de Asignaciones (Streaming & Workers) ---
    // ----------------------------------------------------------------------

    const aggregatedAsignacionesMap = new Map();
    let currentFileDateData = {};

    function processAsignacionesRow(row, fileInfo) {
        const docCol = COL_DOC_PRIN;
        const secAggCol = COL_MES_PRIN;
        const minDateCol = COL_FECHA_PRIN;
        const maxDateCol = COL_FECHA_PRIN;

        const docValue = String(row[docCol] || '').trim();
        const secAggValue = fileInfo.monthFinal; 
        if (!docValue || !secAggValue) return;¬†

        const groupKey = `${docValue}|${secAggValue}`;
        
        const fileDateValue = fileInfo.dateObject;
        
        // Crear una nueva fila con los datos de fecha del archivo
        const rowWithDate = {
            ...row,
            [COL_FECHA_PRIN]: fileInfo.formattedDate,
            [COL_MES_PRIN]: fileInfo.monthFinal,
            [COL_ANIO_PRIN]: fileInfo.year
        };

        if (!aggregatedAsignacionesMap.has(groupKey)) {
            aggregatedAsignacionesMap.set(groupKey, { 
                minDate: fileDateValue, 
                maxDate: fileDateValue, 
                latestRow: rowWithDate 
            });
        } else {
            const data = aggregatedAsignacionesMap.get(groupKey);
            // La fecha del archivo es la fecha clave, no la del campo interno, para mantener consistencia
            if (fileDateValue.getTime() < data.minDate.getTime()) data.minDate = fileDateValue;
            if (fileDateValue.getTime() >= data.maxDate.getTime()) {
                data.maxDate = fileDateValue;
                data.latestRow = rowWithDate;¬†
            }
        }
        
        processedRowsCount++;
        if (processedRowsCount % 5000 === 0) {
            dedupeStatus.textContent = `‚öôÔ∏è Limpiando data de Asignaciones... Filas procesadas: ${processedRowsCount.toLocaleString()}.`;
        }
    }

    function processAsignacionesFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(event) {
                const chunk = event.target.result.substring(0, 1024);
                const delimiter = determineDelimiter(chunk);

                // Obtener datos de fecha del archivo
                const match = file.name.match(/(\d{2}[-.]\d{2}[-.]\d{4})/);¬†
                let fileDateInfo = { formattedDate: '01/01/1900', monthFinal: '1', year: '1900', dateObject: new Date(0) };
                
                if (match) {
                    const dateStr = match[0];
                    const parts = dateStr.match(/(\d{2})[-.](\d{2})[-.](\d{4})/);
                    if (parts && parts.length === 4) {
                        fileDateInfo.formattedDate = `${parts[1]}/${parts[2]}/${parts[3]}`;
                        fileDateInfo.monthFinal = parseInt(parts[2], 10).toString();
                        fileDateInfo.year = parts[3];
                        fileDateInfo.dateObject = new Date(parseInt(parts[3]), parseInt(parts[2]) - 1, parseInt(parts[1]));
                    }
                }

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    delimiter: delimiter,
                    worker: true, // ¬°Usa un Web Worker!
                    step: (results, parser) => {
                        const row = results.data[0];
                        if (results.errors.length === 0) {
                            processAsignacionesRow(row, fileDateInfo);
                        }
                    },
                    complete: () => {
                        resolve();
                    },
                    error: (error) => {
                        console.error(`Error de PapaParse en ${file.name}:`, error);
                        reject(error);
                    }
                });
            };
            reader.readAsText(file.slice(0, 1024 * 10), 'UTF-8');
        });
    }

    async function executeAsignacionesPreProcess(files) {
        if (!dataFilePagos) {
            dedupeStatus.textContent = `‚ö†Ô∏è ERROR: Cargue la Carpeta de Pagos (Paso 1) primero.`;
            dedupeStatus.className = 'alert alert-danger py-1';
            dedupeStatus.style.display = 'block';
            return;
        }

        dedupeStatus.textContent = `‚öôÔ∏è Iniciando limpieza y agregaci√≥n de ${files.length} archivos de Asignaciones (Usando Web Workers)...`;
        dedupeStatus.className = 'alert alert-warning py-1';
        dedupeStatus.style.display = 'block';
        downloadMergeBtn.style.display = 'none';

        // 1. Reiniciar el mapa y el contador
        aggregatedAsignacionesMap.clear();
        processedRowsCount = 0;

        // 2. Procesar todos los archivos en streaming
        for (const file of files) {
            if (!file.name.toLowerCase().endsWith('.csv') && !file.name.toLowerCase().endsWith('.txt')) continue;
            try {
                await processAsignacionesFile(file);
            } catch (e) {
                // El error ya se maneja dentro de processAsignacionesFile
            }
        }
        
        if (aggregatedAsignacionesMap.size === 0) {
            dedupeStatus.textContent = `‚ùå No se encontraron datos v√°lidos en la Carpeta de Asignaciones.`;
            dedupeStatus.className = 'alert alert-danger py-1';
            return;
        }

        dedupeStatus.textContent = `‚öôÔ∏è Finalizando proceso: Aplicando Estado Real y deduplicaci√≥n final...`;
        
        // 3. Post-procesamiento (aplicar l√≥gica de Estado Real)
        
        const docCol = COL_DOC_PRIN;
        const secAggCol = COL_MES_PRIN;
        const minDateCol = 'Ingreso';
        const maxDateCol = 'Salida';
        
        // OBTENER FECHA DE HOY FORMATEADA (Correcci√≥n)
        const today = new Date();
        today.setHours(0, 0, 0, 0);¬†
        const formattedToday = formatDateToDDMMYYYY(today); 
        
        let finalData = [];
        const seenKeys = new Set();
        const dupCols = [docCol, secAggCol, COL_ANIO_PRIN].filter(v => v);

        for (const data of aggregatedAsignacionesMap.values()) {¬†
            const finalRow = data.latestRow;
            
            // Re-formatear fechas de Ingreso/Salida
            const ingresoDateStr = formatDateToDDMMYYYY(data.minDate);
            const salidaDateStr = formatDateToDDMMYYYY(data.maxDate);
            
            finalRow[minDateCol] = ingresoDateStr;
            finalRow[maxDateCol] = salidaDateStr;
            
            // L√ìGICA CORREGIDA: ACTIVO si la Salida es IGUAL A HOY
            finalRow['Estado Real'] = (salidaDateStr === formattedToday) ? 'ACTIVO' : 'INACTIVO';
            
            // Deduplicaci√≥n final basada en Documento/Mes/A√±o
            if (dupCols.length > 0) {
                const key = dupCols.map(col => String(finalRow[col] || '').trim()).join('|');¬†
                if (!seenKeys.has(key)) {
                    seenKeys.add(key);
                    finalData.push(finalRow);
                }
            } else {
                finalData.push(finalRow);
            }
        }
        
        processedDataAsignaciones = finalData;¬†
        const finalRowCount = processedDataAsignaciones.length;
        
        dedupeStatus.textContent = `‚úÖ Limpieza de data de Asignaciones completada. Filas finales: ${finalRowCount.toLocaleString()}.`;
        dedupeStatus.className = 'alert alert-info py-1';
        anexoStatus.textContent = '¬°Archivos consolidados! Iniciando Cruce con Pagos...';
        anexoStatus.className = 'alert alert-success py-1';
        
        // 4. Ejecutar el cruce final
        executeMerge();

    }
    
    // ----------------------------------------------------------------------
    // --- EVENTOS DE CARGA (Usando las nuevas funciones as√≠ncronas) ---
    // ----------------------------------------------------------------------

    // Evento 1: Carga de Carpeta de Pagos (Paso 1)
    pagosFolderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files).filter(file => file.size > 0 && (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')));
        if (files.length === 0) {
            pagosStatus.textContent = 'No se encontraron archivos CSV/TXT v√°lidos en la carpeta.';
            pagosStatus.className = 'alert alert-danger py-1';
            return;
        }
        dataFilePagos = null;¬†
        downloadMergeBtn.style.display = 'none';¬†
        await executePagosProcess(files);
    });

    // Evento 2: Carga de Carpeta de Asignaciones (Paso 2)
    folderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files).filter(file => file.size > 0 && (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')));
        if (files.length === 0) {
            anexoStatus.textContent = 'No se encontraron archivos CSV/TXT v√°lidos en la carpeta.';
            anexoStatus.className = 'alert alert-danger py-1';
            return;
        }

        if (!dataFilePagos) {
            anexoStatus.textContent = '‚ö†Ô∏è Cargue la Carpeta de Pagos (Paso 1) primero.';
            anexoStatus.className = 'alert alert-danger py-1';
            return;
        }
        
        anexoStatus.textContent = `Archivos de Asignaciones listos. Iniciando proceso...`;
        anexoStatus.className = 'alert alert-info py-1';
        
        downloadMergeBtn.style.display = 'none';
        
        await executeAsignacionesPreProcess(files);
    });

</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</body>
</html>
