<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfama Financiera - YesBPO | Automatización de Datos</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body { background-color: #f4f7f6; display: flex; flex-direction: column; min-height: 100vh; }
        .container { max-width: 1400px; margin-top: 20px; background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex-grow: 1; }
        .section-panel { padding: 15px; border: 1px solid #e0e0e0; border-radius: 0.25rem; margin-bottom: 20px; }
        .step-divider { border-top: 4px solid #0d6efd; margin-top: 30px; margin-bottom: 30px; padding-top: 15px; }
        h1 { color: #0d6efd; font-weight: 700; margin-bottom: 30px; }
        .section-title { font-size: 1.5rem; color: #495057; border-bottom: 2px solid #0d6efd; padding-bottom: 10px; margin-bottom: 20px; }
        /* Clases para ocultar elementos de configuración y filtros */
        .hidden-preview { display: none !important; }
        .hidden-filters select, .hidden-filters button { display: none !important; } 
        .footer { padding: 15px 0; background-color: #e9ecef; color: #6c757d; text-align: center; margin-top: 20px; font-size: 0.85rem; }
    </style>
</head>
<body>

<div class="container">
    <h1 class="text-center">Comfama Financiera - YesBPO | Automatización</h1>

    <div id="pagosSection" class="section-panel">
        <div class="section-title text-success">1. Carpeta de Pagos (Consolidación y Transformación)</div>
        
        <p class="fw-bold">1.1 Carga de Carpeta de Pagos</p>
        <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="pagosFolderInput">
        <div class="alert alert-info py-1" id="pagosStatus">Cargue la **Carpeta de Pagos** para iniciar la consolidación y transformación.</div>
        
        <div class="alert alert-light mt-2 py-1" id="pagosProcessStatus" style="display:none;"></div>
        
        <div class="hidden-filters">
            <select id="col1Select" class="form-select"></select>
            <select id="col2Select" class="form-select"></select>
            <select id="col3Select" class="form-select"></select>
            <select id="col4Select" class="form-select"></select>
            <button id="executeMerge">REALIZAR CRUCE DE DATOS (LEFT JOIN)</button>
        </div>
    </div>
    
    <div class="section-panel step-divider">
        <div class="section-title">2. Carpeta de Asignaciones (Proceso Automático)</div>
        
        <p class="fw-bold">2.1 Carga de Carpeta de Asignaciones (Principal)</p>
        <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="folderInput">
        <div class="alert alert-info py-1" id="anexoStatus">Cargue la **Carpeta de Asignaciones** para iniciar el proceso de Limpieza y Cruce.</div>
        
        <p class="fw-bold mt-4">2.2 Proceso Automático (Limpieza y Cruce)</p>
        
        <div class="alert alert-light mt-2 py-1" id="dedupeStatus" style="display:none;"></div>
        
        <div id="preProcessConfig" class="hidden-filters">
            <select id="docColSelect" class="form-select"></select>
            <select id="secAggColSelect" class="form-select"></select>
            <select id="minColSelect" class="form-select"></select>
            <select id="maxColSelect" class="form-select"></select>
            <select id="dupCol1Select" class="form-select"></select>
            <select id="dupCol2Select" class="form-select"></select>
            <select id="dupCol3Select" class="form-select"></select>
        </div>
        
        <div class="d-grid gap-2 d-md-flex justify-content-md-start mt-4">
            <button class="btn btn-primary btn-lg" onclick="downloadFile(mergedData, 'resultado_cruce_final.csv', '|');" id="downloadMergeBtn" style="display:none;">
                Descargar Data
            </button>
            <button id="downloadAnexoBtn" style="display:none;"></button>
        </div>
        
    </div>
</div>

<footer class="footer">
    Autoría: Andrés Vanegas - Área de Inteligencia YesBPO
</footer>

<script>
    // Variables globales
    let dataFilePagos = null;    // Resultado del Paso 1 (Pagos procesados)
    let dataFileAsignaciones = null; // Data consolidada cruda del Paso 2
    let processedDataAsignaciones = null; // Resultado de la limpieza del Paso 2
    let mergedData = null;       

    // Elementos del DOM
    const folderInput = document.getElementById('folderInput');
    const anexoStatus = document.getElementById('anexoStatus');
    const dedupeStatus = document.getElementById('dedupeStatus');
    const downloadMergeBtn = document.getElementById('downloadMergeBtn');
    
    // Elementos del nuevo Paso 1 (Pagos)
    const pagosFolderInput = document.getElementById('pagosFolderInput');
    const pagosStatus = document.getElementById('pagosStatus');
    const pagosProcessStatus = document.getElementById('pagosProcessStatus');
    
    // Selectores Ocultos (Mantenidos por consistencia de la lógica)
    const docColSelect = document.getElementById('docColSelect'); 
    const secAggColSelect = document.getElementById('secAggColSelect'); 
    const minColSelect = document.getElementById('minColSelect');
    const maxColSelect = document.getElementById('maxColSelect'); 
    const dupCol1Select = document.getElementById('dupCol1Select');
    const dupCol2Select = document.getElementById('dupCol2Select');
    const dupCol3Select = document.getElementById('dupCol3Select');
    const col1Select = document.getElementById('col1Select'); 
    const col2Select = document.getElementById('col2Select'); 
    const col3Select = document.getElementById('col3Select'); 
    const col4Select = document.getElementById('col4Select'); 

    // --- Definición de Nombres de Columnas para Automatización ---
    // Asignaciones (Paso 2 - Principal)
    const COL_DOC_PRIN = 'Numero Documento';
    const COL_MES_PRIN = 'Mes data';
    const COL_FECHA_PRIN = 'Nombre del archivo';
    const COL_ANIO_PRIN = 'Año';

    // Pagos (Paso 1 - Secundario) - Columnas requeridas después de la transformación
    const COL_DOC_PAGOS = 'Numero de Documento';
    const COL_MES_PAGOS = 'MES';
    const COL_FECHA_MAX_PAGOS = 'Fecha_Movimiento_Maxima';
    const COL_VALOR_PAGADO = 'Suma_Valor_Pagado';
    // Columna a procesar en Pagos
    const COL_FECHA_MOV = 'Fecha Movimiento'; 

    // --- Funciones de Utilidad y Transformación ---

    function determineDelimiter(fileChunk) {
        if (fileChunk.includes('|')) return '|';
        if (fileChunk.includes(';')) return ';';
        return ','; // Delimitador por defecto
    }

    function parseFile(file, fastMode = false) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(event) {
                const chunk = event.target.result.substring(0, 1024);
                const delimiter = determineDelimiter(chunk);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    delimiter: delimiter, 
                    fastMode: fastMode, 
                    complete: (results) => resolve(results),
                    error: (error) => reject(error)
                });
            };
            reader.onerror = (error) => reject(error);
            reader.readAsText(file.slice(0, 1024 * 10), 'UTF-8'); // Leer los primeros 10KB para identificar el delimitador
        });
    }

    function downloadFile(data, filename, delimiter) {
        if (!data) {
            alert('No hay datos disponibles para descargar.');
            return;
        }
        const finalData = Array.isArray(data) ? data : data.data;
        const csv = Papa.unparse(finalData, { delimiter: delimiter, header: true });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    const parseDate = (dateString) => {
        if (!dateString) return new Date(0); 
        let dateParts = dateString.match(/(\d{1,2})[-./](\d{1,2})[-./](\d{4})/);
        if (dateParts) {
            // Asume DD/MM/YYYY o DD.MM.YYYY
            const d = new Date(parseInt(dateParts[3]), parseInt(dateParts[2]) - 1, parseInt(dateParts[1]));
            if (!isNaN(d.getTime())) return d;
        } 
        dateParts = dateString.match(/(\d{4})-(\d{2})-(\d{2})/);
         if (dateParts) {
            // Asume YYYY-MM-DD
            const d = new Date(parseInt(dateParts[1]), parseInt(dateParts[2]) - 1, parseInt(dateParts[3]));
            if (!isNaN(d.getTime())) return d;
        } 
        return new Date(0); 
    };
    
    const formatDateToDDMMYYYY = (date) => {
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0'); 
        const year = d.getFullYear();
        return `${day}/${month}/${year}`;
    };

    function populateSelectors(fields, selectors, presets = {}) {
        selectors.forEach(select => {
            select.innerHTML = '';
            fields.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
            const presetValue = presets[select.id];
            if (presetValue && fields.includes(presetValue)) {
                select.value = presetValue;
            }
        });
    }

    function populateColumnSelectorsForMerge(fields1, fields2) {
        const selectors1 = [col1Select, col3Select];
        const selectors2 = [col2Select, col4Select];
        
        // 1. Archivo Principal (Asignaciones)
        selectors1.forEach(select => {
            const isKey1 = (select.id === 'col1Select');
            select.innerHTML = '';
            fields1.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
            if (isKey1 && fields1.includes(COL_DOC_PRIN)) {
                select.value = COL_DOC_PRIN;
            } else if (!isKey1 && fields1.includes(COL_MES_PRIN)) {
                select.value = COL_MES_PRIN;
            }
        });

        // 2. Archivo Secundario (Pagos)
        selectors2.forEach(select => {
            const isKey1 = (select.id === 'col2Select');
            select.innerHTML = '';
            fields2.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
            // Automáticamente seleccionamos las columnas transformadas de Pagos
            if (isKey1 && fields2.includes(COL_DOC_PAGOS)) {
                select.value = COL_DOC_PAGOS;
            } else if (!isKey1 && fields2.includes(COL_MES_PAGOS)) {
                select.value = COL_MES_PAGOS;
            }
        });
    }

    // --- Lógica del Cruce ---

    function executeMerge() {
        if (!processedDataAsignaciones || !dataFilePagos) {
            return;
        }

        const key1_A = col1Select.value; // Numero Documento Asignaciones
        const key1_B = col2Select.value; // Numero de Documento Pagos
        const key2_A = col3Select.value; // Mes data Asignaciones
        const key2_B = col4Select.value; // MES Pagos
        
        if (!key1_A || !key1_B || !key2_A || !key2_B) {
            dedupeStatus.textContent = 'ERROR: No se pudo configurar el cruce. Faltan claves (Documento o Mes).';
            dedupeStatus.className = 'alert alert-danger py-1';
            return;
        }

        dedupeStatus.textContent = '🚀 CRUCE DE DATOS AUTOMÁTICO EN CURSO... Por favor, espere.';
        dedupeStatus.className = 'alert alert-warning py-1';
        downloadMergeBtn.style.display = 'none'; 

        setTimeout(() => {
            
            const data1 = processedDataAsignaciones;
            const data2 = dataFilePagos;
            
            // Los headers de Pagos son las 4 columnas transformadas
            const headers2 = [COL_FECHA_MAX_PAGOS, COL_VALOR_PAGADO];

            // 1. Crear el mapa de búsqueda (data2 - Pagos)
            const map2 = new Map();
            data2.forEach(row => {
                // Clave compuesta: Documento|MES
                const keyValue = `${String(row[key1_B] || '').trim()}|${String(row[key2_B] || '').trim()}`;
                
                if (keyValue) {
                    const rowData = {};
                    headers2.forEach(field => rowData[field] = row[field]);
                    // En Pagos ya está agrupado, solo debería haber una fila por clave
                    map2.set(keyValue, rowData);
                }
            });
            
            dataFilePagos = null; 

            // 2. Realizar el LEFT JOIN (data1 - Asignaciones)
            const mergedResults = [];
            
            data1.forEach(row1 => {
                // Clave de búsqueda: Documento|Mes data
                const searchKey = `${String(row1[key1_A] || '').trim()}|${String(row1[key2_A] || '').trim()}`;

                const row2Data = map2.get(searchKey) || {};
                
                const newRow = { ...row1 }; 
                let isMatch = Object.keys(row2Data).length > 0;
                
                for (const field of headers2) {
                    // Agregamos las columnas Fecha_Movimiento_Maxima y Suma_Valor_Pagado
                    newRow[field] = isMatch ? row2Data[field] : ''; 
                }
                mergedResults.push(newRow);
            });

            mergedData = mergedResults;
            
            if (mergedData.length > 0) {
                dedupeStatus.textContent = `✅ **PROCESO FINALIZADO**. Data lista para descargar.`;
                dedupeStatus.className = 'alert alert-success py-1';
                downloadMergeBtn.style.display = 'block'; 
            } else {
                dedupeStatus.textContent = `⚠️ Error: El cruce no generó resultados válidos.`;
                dedupeStatus.className = 'alert alert-danger py-1';
            }
            
            // Liberar memoria
            processedDataAsignaciones = null;

        }, 50); 
    }

    // --- Lógica del Procesamiento de Pagos (Paso 1) ---

    async function executePagosProcess(files) {
        pagosProcessStatus.textContent = `⚙️ Consolidando ${files.length} archivos de Pagos...`;
        pagosProcessStatus.className = 'alert alert-warning py-1';
        pagosProcessStatus.style.display = 'block';

        const allData = [];
        let totalFilesProcessed = 0;

        for (const file of files) {
            if (!file.name.toLowerCase().endsWith('.csv') && !file.name.toLowerCase().endsWith('.txt')) continue;
            try {
                const results = await parseFile(file, true); 
                allData.push(...results.data);
                totalFilesProcessed++;
            } catch (e) {
                console.error(`Error al parsear archivo ${file.name}:`, e);
            }
        }
        
        if (allData.length === 0) {
            pagosProcessStatus.textContent = '❌ No se encontraron datos válidos en la Carpeta de Pagos.';
            pagosProcessStatus.className = 'alert alert-danger py-1';
            return;
        }

        pagosProcessStatus.textContent = `⚙️ Agrupando y transformando ${allData.length} filas...`;
        
        // 1. Agrupar, transformar y agregar
        const aggregatedMap = new Map();

        allData.forEach(row => {
            // Transformación: Crear MES y Normalizar Valor_Pagado y Doc
            const docValue = String(row[COL_DOC_PAGOS] || '').trim();
            const fechaMovStr = String(row[COL_FECHA_MOV] || '').trim();
            let valorPagado = parseFloat(String(row[COL_VALOR_PAGADO] || '0').replace(/\./g, '').replace(/,/g, '.')) || 0;
            
            if (!docValue || !fechaMovStr) return; 

            const fechaMov = parseDate(fechaMovStr);
            if (isNaN(fechaMov.getTime())) return;

            const mes = String(fechaMov.getMonth() + 1); // 1-12
            const groupKey = `${docValue}|${mes}`;
            
            if (!aggregatedMap.has(groupKey)) {
                aggregatedMap.set(groupKey, {
                    [COL_DOC_PAGOS]: docValue,
                    [COL_MES_PAGOS]: mes,
                    [COL_FECHA_MOV]: fechaMov, // Usamos la fecha real (Date object) para el cálculo del Max
                    [COL_VALOR_PAGADO]: valorPagado,
                });
            } else {
                const data = aggregatedMap.get(groupKey);
                // Fecha Máxima
                if (fechaMov.getTime() > data[COL_FECHA_MOV].getTime()) {
                    data[COL_FECHA_MOV] = fechaMov;
                }
                // Suma de Valores
                data[COL_VALOR_PAGADO] += valorPagado;
            }
        });
        
        // 2. Formato final y eliminación de columnas
        dataFilePagos = Array.from(aggregatedMap.values()).map(data => {
            return {
                [COL_DOC_PAGOS]: data[COL_DOC_PAGOS],
                [COL_MES_PAGOS]: data[COL_MES_PAGOS],
                [COL_FECHA_MAX_PAGOS]: formatDateToDDMMYYYY(data[COL_FECHA_MOV]), // Formatear la fecha máxima
                [COL_VALOR_PAGADO]: data[COL_VALOR_PAGADO],
            };
        });

        pagosProcessStatus.textContent = `✅ **Proceso de Pagos Completado**. Filas: ${dataFilePagos.length}.`;
        pagosProcessStatus.className = 'alert alert-success py-1';
        pagosStatus.textContent = `Consolidación de Pagos finalizada. Ahora, cargue la Carpeta de Asignaciones (Paso 2).`;
        pagosStatus.className = 'alert alert-success py-1';

        // Si la data de Asignaciones ya está lista, iniciar el cruce
        if (processedDataAsignaciones) {
            const fields1 = Object.keys(processedDataAsignaciones[0]);
            const fields2 = Object.keys(dataFilePagos[0]);
            populateColumnSelectorsForMerge(fields1, fields2);
            executeMerge();
        }
    }

    // --- Lógica del Procesamiento de Asignaciones (Paso 2) ---

    function executeAsignacionesPreProcess() {
        if (!dataFileAsignaciones) return; 

        dedupeStatus.textContent = `⚙️ Iniciando limpieza y agregación de la data de Asignaciones...`;
        dedupeStatus.className = 'alert alert-warning py-1';
        dedupeStatus.style.display = 'block';
        downloadMergeBtn.style.display = 'none';

        setTimeout(() => {
            // La configuración se asume de la versión anterior
            const docCol = COL_DOC_PRIN;
            const secAggCol = COL_MES_PRIN; 
            const minDateCol = COL_FECHA_PRIN; 
            const maxDateCol = COL_FECHA_PRIN; 
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); 
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const formattedYesterday = formatDateToDDMMYYYY(yesterday);
            const aggregatedMap = new Map();
            
            // --- AGRUPACIÓN Y AGREGACIÓN ---
            dataFileAsignaciones.forEach(row => {
                const docValue = String(row[docCol] || '').trim();
                const secAggValue = String(row[secAggCol] || '').trim(); 
                if (!docValue || !secAggValue) return; 
                const groupKey = `${docValue}|${secAggValue}`;
                
                const minDateValue = parseDate(row[minDateCol]);
                const maxDateValue = parseDate(row[maxDateCol]);
                if (isNaN(minDateValue.getTime()) || isNaN(maxDateValue.getTime())) return; 
                
                if (!aggregatedMap.has(groupKey)) {
                    aggregatedMap.set(groupKey, { minDate: minDateValue, maxDate: maxDateValue, latestRow: {...row} });
                } else {
                    const data = aggregatedMap.get(groupKey);
                    if (minDateValue.getTime() < data.minDate.getTime()) data.minDate = minDateValue;
                    if (maxDateValue.getTime() >= data.maxDate.getTime()) {
                        data.maxDate = maxDateValue;
                        data.latestRow = {...row}; 
                    }
                }
            });
            
            let finalData = [];
            for (const data of aggregatedMap.values()) { 
                const finalRow = data.latestRow;
                const salidaDateStr = formatDateToDDMMYYYY(data.maxDate);
                finalRow['Ingreso'] = formatDateToDDMMYYYY(data.minDate);
                finalRow['Salida'] = salidaDateStr;
                finalRow['Estado Real'] = (salidaDateStr === formattedYesterday) ? 'ACTIVO' : 'INACTIVO';
                finalData.push(finalRow);
            }
            
            // Lógica de Deduplicación (Se usa la lógica de la versión anterior)
            const dupCols = [docCol, secAggCol, COL_ANIO_PRIN].filter(v => v);
            let deduplicatedData = [];
            const seenKeys = new Set();
            
            if (dupCols.length > 0) {
                 finalData.forEach(row => {
                    const key = dupCols.map(col => String(row[col] || '').trim()).join('|'); 
                    if (!seenKeys.has(key)) {
                        seenKeys.add(key);
                        deduplicatedData.push(row);
                    }
                });
                finalData = deduplicatedData;
            }
            
            processedDataAsignaciones = finalData; 
            const finalRowCount = processedDataAsignaciones.length;
            dataFileAsignaciones = null; 
            
            // Actualizar UI
            dedupeStatus.textContent = `✅ Limpieza de data de Asignaciones completada. Filas finales: ${finalRowCount}.`;
            dedupeStatus.className = 'alert alert-info py-1';
            
            // Si el archivo de Pagos ya está procesado, ¡ejecutar el cruce de inmediato!
            if (dataFilePagos) {
                const fields1 = Object.keys(processedDataAsignaciones[0]);
                const fields2 = Object.keys(dataFilePagos[0]);
                populateColumnSelectorsForMerge(fields1, fields2);
                executeMerge();
            } else {
                dedupeStatus.textContent = `✅ Limpieza de Asignaciones completada. Ahora, cargue la Carpeta de Pagos (Paso 1) para realizar el Cruce.`;
                dedupeStatus.className = 'alert alert-info py-1';
                anexoStatus.textContent = `Limpieza completada. Ya puede cargar la Carpeta de Pagos (Paso 1).`;
                anexoStatus.className = 'alert alert-success py-1';
            }

        }, 50);
    }
    
    // --- EVENTOS DE CARGA ---

    // Evento 1: Carga de Carpeta de Pagos (Paso 1)
    pagosFolderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files).filter(file => file.size > 0 && (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')));
        if (files.length === 0) {
            pagosStatus.textContent = 'No se encontraron archivos CSV/TXT válidos en la carpeta.';
            pagosStatus.className = 'alert alert-danger py-1';
            return;
        }
        dataFilePagos = null; // Resetear
        executePagosProcess(files);
        downloadMergeBtn.style.display = 'none'; // Ocultar mientras procesa
    });

    // Evento 2: Carga de Carpeta de Asignaciones (Paso 2)
    folderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files).filter(file => file.size > 0 && (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')));
        if (files.length === 0) {
            anexoStatus.textContent = 'No se encontraron archivos CSV/TXT válidos en la carpeta.';
            anexoStatus.className = 'alert alert-danger py-1';
            return;
        }

        anexoStatus.textContent = `Analizando ${files.length} archivos de Asignaciones...`;
        anexoStatus.className = 'alert alert-warning py-1';

        const allData = [];
        let headers = new Set();
        
        downloadMergeBtn.style.display = 'none';

        for (const file of files) {
            try {
                const results = await parseFile(file, true); 
                
                // Lógica de metadatos (igual que antes)
                const match = file.name.match(/(\d{2}[-.]\d{2}[-.]\d{4})/); 
                let formattedDate = '01/01/1900'; 
                let month = '01';
                let year = '1900';
                
                if (match) {
                    const dateStr = match[0];
                    const parts = dateStr.match(/(\d{2})[-.](\d{2})[-.](\d{4})/);
                    if (parts && parts.length === 4) {
                        formattedDate = `${parts[1]}/${parts[2]}/${parts[3]}`; 
                        month = parts[2];
                        year = parts[3];
                    }
                }
                const monthFinal = parseInt(month, 10).toString(); 

                const processedRows = results.data.map(row => {
                    const newRow = {...row};
                    newRow[COL_FECHA_PRIN] = formattedDate; 
                    newRow[COL_MES_PRIN] = monthFinal; 
                    newRow[COL_ANIO_PRIN] = year; 
                    return newRow;
                });
                
                allData.push(...processedRows);
                processedRows.forEach(row => Object.keys(row).forEach(header => headers.add(header)));

            } catch (e) {
                console.error(`Error al parsear archivo ${file.name}:`, e);
            }
        }
        
        if (allData.length > 0) {
            dataFileAsignaciones = allData; 
            anexoStatus.textContent = `¡Consolidación de Asignaciones lista! Iniciando limpieza automática...`;
            anexoStatus.className = 'alert alert-info py-1';
            
            // Ejecutar la limpieza y luego el cruce si Pagos está listo
            executeAsignacionesPreProcess();

        } else {
            anexoStatus.textContent = 'No se encontraron archivos CSV/TXT válidos.';
            anexoStatus.className = 'alert alert-danger py-1';
        }
    });

</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</body>
</html>
