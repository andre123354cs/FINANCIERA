<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfama Financiera - YesBPO | Automatización de Datos con Caché</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body { background-color: #f4f7f6; display: flex; flex-direction: column; min-height: 100vh; }
        .container { max-width: 1400px; margin-top: 20px; background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); flex-grow: 1; }
        .section-panel { padding: 15px; border: 1px solid #e0e0e0; border-radius: 0.25rem; margin-bottom: 20px; }
        .step-divider { border-top: 4px solid #0d6efd; margin-top: 30px; margin-bottom: 30px; padding-top: 15px; }
        h1 { color: #0d6efd; font-weight: 700; margin-bottom: 30px; }
        .section-title { font-size: 1.5rem; color: #495057; border-bottom: 2px solid #0d6efd; padding-bottom: 10px; margin-bottom: 20px; }
        /* Clases para ocultar elementos de configuración y filtros */
        .hidden-preview { display: none !important; }
        .hidden-filters select, .hidden-filters button { display: none !important; } 
        .footer { padding: 15px 0; background-color: #e9ecef; color: #6c757d; text-align: center; margin-top: 20px; font-size: 0.85rem; }
    </style>
</head>
<body onload="loadCacheOnStart()">

<div class="container">
    <h1 class="text-center">Comfama Financiera - YesBPO | Automatización</h1>
    
    <div class="alert alert-warning py-2 mb-4" id="cacheStatus" style="display:none;"></div>

    <div id="pagosSection" class="section-panel">
        <div class="section-title text-success">1. Carpeta de Pagos (Consolidación y Transformación)</div>
        
        <p class="fw-bold">1.1 Carga de Carpeta de Pagos</p>
        <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="pagosFolderInput">
        <div class="alert alert-info py-1" id="pagosStatus">Cargue la **Carpeta de Pagos** (si desea actualizar la data) o cargue directamente el Paso 2.</div>
        
        <div class="alert alert-light mt-2 py-1" id="pagosProcessStatus" style="display:none;"></div>
        
        <div class="hidden-filters">
            <select id="col1Select" class="form-select"></select>
            <select id="col2Select" class="form-select"></select>
            <select id="col3Select" class="form-select"></select>
            <select id="col4Select" class="form-select"></select>
            <button id="executeMerge">REALIZAR CRUCE DE DATOS (LEFT JOIN)</button>
        </div>
    </div>
    
    <div class="section-panel step-divider">
        <div class="section-title">2. Carpeta de Asignaciones (Proceso Automático)</div>
        
        <p class="fw-bold">2.1 Carga de Carpeta de Asignaciones (Principal)</p>
        <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="folderInput">
        <div class="alert alert-info py-1" id="anexoStatus">Cargue la **Carpeta de Asignaciones** para iniciar el proceso de Limpieza y Cruce.</div>
        
        <p class="fw-bold mt-4">2.2 Proceso Automático (Limpieza y Cruce)</p>
        
        <div class="alert alert-light mt-2 py-1" id="dedupeStatus" style="display:none;"></div>
        
        <div id="preProcessConfig" class="hidden-filters">
            <select id="docColSelect" class="form-select"></select>
            <select id="secAggColSelect" class="form-select"></select>
            <select id="minColSelect" class="form-select"></select>
            <select id="maxColSelect" class="form-select"></select>
            <select id="dupCol1Select" class="form-select"></select>
            <select id="dupCol2Select" class="form-select"></select>
            <select id="dupCol3Select" class="form-select"></select>
        </div>
        
        <div class="d-grid gap-2 d-md-flex justify-content-md-start mt-4">
            <button class="btn btn-primary btn-lg" onclick="downloadFile(mergedData, 'resultado_cruce_final.csv', '|');" id="downloadMergeBtn" style="display:none;">
                Descargar Data
            </button>
            <button id="downloadAnexoBtn" style="display:none;"></button>
        </div>
        
    </div>
</div>

<footer class="footer">
    Autoría: Andrés Vanegas - Área de Inteligencia YesBPO
</footer>

<script>
    // Variables globales
    let db;                     // Objeto IndexedDB
    const CACHE_KEY_PAGOS = 'processedPagosData';

    let dataFilePagos = null;    
    let dataFileAsignaciones = null; 
    let processedDataAsignaciones = null; 
    let mergedData = null;       

    // Elementos del DOM
    const folderInput = document.getElementById('folderInput');
    const anexoStatus = document.getElementById('anexoStatus');
    const dedupeStatus = document.getElementById('dedupeStatus');
    const downloadMergeBtn = document.getElementById('downloadMergeBtn');
    const cacheStatus = document.getElementById('cacheStatus'); // Lo mantenemos pero oculto
    
    // Elementos del nuevo Paso 1 (Pagos)
    const pagosFolderInput = document.getElementById('pagosFolderInput');
    const pagosStatus = document.getElementById('pagosStatus');
    const pagosProcessStatus = document.getElementById('pagosProcessStatus');
    
    // Nombres de Columnas
    const COL_DOC_PRIN = 'Numero Documento';
    const COL_MES_PRIN = 'Mes data';
    const COL_FECHA_PRIN = 'Nombre del archivo';
    const COL_ANIO_PRIN = 'Año';
    const COL_DOC_PAGOS = 'Numero de Documento';
    const COL_MES_PAGOS = 'MES';
    const COL_FECHA_MAX_PAGOS = 'Fecha_Movimiento_Maxima';
    const COL_VALOR_PAGADO = 'Suma_Valor_Pagado';
    const COL_VALOR_PAGADO_RAW = 'Valor Pagado'; 
    const COL_FECHA_MOV = 'Fecha Movimiento'; 

    // --- Funciones de IndexedDB (CACHÉ) ---

    function initDB() {
        return new Promise((resolve, reject) => {
            if (!window.indexedDB) {
                // Si no hay soporte, solo logeamos el error (en consola) y resolvemos.
                console.warn('IndexedDB no soportado. Caché deshabilitado.');
                return resolve(null);
            }

            const request = window.indexedDB.open("ComfamaCacheDB", 1);

            request.onerror = (event) => {
                console.error(`Error al abrir la base de datos: ${event.target.errorCode}`, event.target.error);
                reject(event.target.error);
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };

            request.onupgradeneeded = (event) => {
                const dbInstance = event.target.result;
                if (!dbInstance.objectStoreNames.contains('dataStore')) {
                    dbInstance.createObjectStore('dataStore', { keyPath: 'key' });
                }
            };
        });
    }

    function saveDataToCache(key, data) {
        if (!db) return Promise.resolve(); // Operación silenciosa si DB no está lista
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(['dataStore'], 'readwrite');
            const store = transaction.objectStore('dataStore');
            const dataToStore = { key: key, data: data, timestamp: new Date() };

            const request = store.put(dataToStore);

            request.onsuccess = () => {
                // MENSAJE DE CACHÉ ELIMINADO/SILENCIADO
                resolve();
            };

            request.onerror = (event) => {
                console.error('Error al guardar en caché.', event.target.error);
                reject(event.target.error);
            };
        });
    }

    function loadDataFromCache(key) {
        if (!db) return Promise.resolve(null);
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(['dataStore'], 'readonly');
            const store = transaction.objectStore('dataStore');
            const request = store.get(key);

            request.onsuccess = () => {
                const result = request.result;
                if (result && result.data && result.data.length > 0) {
                    const loadedData = result.data;
                    dataFilePagos = loadedData;
                    
                    // MENSAJE DE CARGA DE CACHÉ SIMPLIFICADO Y MOVIDO
                    pagosStatus.textContent = `✅ Data de Pagos (Caché) cargada. Lista para usar.`;
                    pagosStatus.className = 'alert alert-success py-1';
                    
                    resolve(loadedData);
                } else {
                    // MENSAJE DE CACHÉ NO ENCONTRADO SIMPLIFICADO
                    pagosStatus.textContent = 'ℹ️ Data de Pagos no encontrada en caché. Cargue la Carpeta de Pagos (Paso 1).';
                    pagosStatus.className = 'alert alert-info py-1';
                    resolve(null);
                }
            };

            request.onerror = (event) => {
                console.error('Error al cargar el caché.', event.target.error);
                resolve(null);
            };
        });
    }

    async function loadCacheOnStart() {
        // Inicializa DB de forma silenciosa
        try {
            await initDB();
            // Intenta cargar la data de Pagos
            await loadDataFromCache(CACHE_KEY_PAGOS);
            
        } catch (e) {
            console.error('Fallo grave al inicializar la base de datos de caché.', e);
        }
    }

    // --- Funciones de Utilidad y Transformación (Igual que antes) ---

    function determineDelimiter(fileChunk) {
        if (fileChunk.includes('|')) return '|';
        if (fileChunk.includes(';')) return ';';
        return ',';
    }

    function parseFile(file, fastMode = false) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(event) {
                const chunk = event.target.result.substring(0, 1024);
                const delimiter = determineDelimiter(chunk);
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    delimiter: delimiter, 
                    fastMode: fastMode, 
                    complete: (results) => resolve(results),
                    error: (error) => reject(error)
                });
            };
            reader.onerror = (error) => reject(error);
            reader.readAsText(file.slice(0, 1024 * 10), 'UTF-8'); 
        });
    }

    function downloadFile(data, filename, delimiter) {
        if (!data) {
            alert('No hay datos disponibles para descargar.');
            return;
        }
        const finalData = Array.isArray(data) ? data : data.data;
        const csv = Papa.unparse(finalData, { delimiter: delimiter, header: true });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    const parseDate = (dateString) => {
        if (!dateString) return new Date(0); 
        let dateParts = dateString.match(/(\d{1,2})[-./](\d{1,2})[-./](\d{4})/);
        if (dateParts) {
            const d = new Date(parseInt(dateParts[3]), parseInt(dateParts[2]) - 1, parseInt(dateParts[1]));
            if (!isNaN(d.getTime())) return d;
        } 
        dateParts = dateString.match(/(\d{4})-(\d{2})-(\d{2})/);
         if (dateParts) {
            const d = new Date(parseInt(dateParts[1]), parseInt(dateParts[2]) - 1, parseInt(dateParts[3]));
            if (!isNaN(d.getTime())) return d;
        } 
        return new Date(0); 
    };
    
    const formatDateToDDMMYYYY = (date) => {
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0'); 
        const year = d.getFullYear();
        return `${day}/${month}/${year}`;
    };

    function getIntegerValue(value) {
        if (value === null || value === undefined) return 0;
        let strValue = String(value).trim();
        
        const splitIndex = strValue.indexOf('.');
        
        let integerPart = (splitIndex !== -1) ? strValue.substring(0, splitIndex) : strValue;
        
        integerPart = integerPart.replace(/[^0-9-]/g, ''); 
        return parseInt(integerPart, 10) || 0;
    }


    // --- Lógica del Cruce (Igual que antes) ---

    function executeMerge() {
        if (!processedDataAsignaciones || !dataFilePagos) {
            return;
        }

        const key1_A = COL_DOC_PRIN;
        const key1_B = COL_DOC_PAGOS;
        const key2_A = COL_MES_PRIN;
        const key2_B = COL_MES_PAGOS;
        
        dedupeStatus.textContent = '🚀 CRUCE DE DATOS AUTOMÁTICO EN CURSO... Por favor, espere.';
        dedupeStatus.className = 'alert alert-warning py-1';
        downloadMergeBtn.style.display = 'none'; 

        setTimeout(() => {
            
            const data1 = processedDataAsignaciones;
            const data2 = dataFilePagos;
            
            const headers2 = [COL_FECHA_MAX_PAGOS, COL_VALOR_PAGADO];

            // 1. Crear el mapa de búsqueda (data2 - Pagos)
            const map2 = new Map();
            data2.forEach(row => {
                const keyValue = `${String(row[key1_B] || '').trim()}|${String(row[key2_B] || '').trim()}`;
                
                if (keyValue) {
                    const rowData = {};
                    headers2.forEach(field => rowData[field] = row[field]);
                    map2.set(keyValue, rowData);
                }
            });
            
            const mergedResults = [];
            
            data1.forEach(row1 => {
                const searchKey = `${String(row1[key1_A] || '').trim()}|${String(row1[key2_A] || '').trim()}`;

                const row2Data = map2.get(searchKey) || {};
                
                const newRow = { ...row1 }; 
                let isMatch = Object.keys(row2Data).length > 0;
                
                for (const field of headers2) {
                    newRow[field] = isMatch ? row2Data[field] : ''; 
                }
                mergedResults.push(newRow);
            });

            mergedData = mergedResults;
            
            if (mergedData.length > 0) {
                dedupeStatus.textContent = `✅ **PROCESO FINALIZADO**. Data lista para descargar.`;
                dedupeStatus.className = 'alert alert-success py-1';
                downloadMergeBtn.style.display = 'block'; 
            } else {
                dedupeStatus.textContent = `⚠️ Error: El cruce no generó resultados válidos. Revise la Carpeta de Pagos y la Carpeta de Asignaciones.`;
                dedupeStatus.className = 'alert alert-danger py-1';
            }
            
            processedDataAsignaciones = null; 

        }, 50); 
    }

    // --- Lógica del Procesamiento de Pagos (Paso 1) ---

    async function executePagosProcess(files) {
        pagosProcessStatus.textContent = `⚙️ Consolidando ${files.length} archivos de Pagos...`;
        pagosProcessStatus.className = 'alert alert-warning py-1';
        pagosProcessStatus.style.display = 'block';

        const allData = [];

        for (const file of files) {
            if (!file.name.toLowerCase().endsWith('.csv') && !file.name.toLowerCase().endsWith('.txt')) continue;
            try {
                const results = await parseFile(file, true); 
                allData.push(...results.data);
            } catch (e) {
                console.error(`Error al parsear archivo ${file.name}:`, e);
            }
        }
        
        if (allData.length === 0) {
            pagosProcessStatus.textContent = '❌ No se encontraron datos válidos en la Carpeta de Pagos.';
            pagosProcessStatus.className = 'alert alert-danger py-1';
            return;
        }

        pagosProcessStatus.textContent = `⚙️ Agrupando y transformando datos (Max. Fecha y Suma Entera)...`;
        
        const aggregatedMap = new Map();

        allData.forEach(row => {
            const valorPagadoEntero = getIntegerValue(row[COL_VALOR_PAGADO_RAW]);
            
            const docValue = String(row[COL_DOC_PAGOS] || '').trim();
            const fechaMovStr = String(row[COL_FECHA_MOV] || '').trim();
            
            if (!docValue || !fechaMovStr) return; 

            const fechaMov = parseDate(fechaMovStr);
            if (isNaN(fechaMov.getTime())) return;

            const mes = String(fechaMov.getMonth() + 1); // 1-12
            const groupKey = `${docValue}|${mes}`;
            
            if (!aggregatedMap.has(groupKey)) {
                aggregatedMap.set(groupKey, {
                    [COL_DOC_PAGOS]: docValue,
                    [COL_MES_PAGOS]: mes,
                    [COL_FECHA_MOV]: fechaMov, 
                    [COL_VALOR_PAGADO]: valorPagadoEntero, 
                });
            } else {
                const data = aggregatedMap.get(groupKey);
                if (fechaMov.getTime() > data[COL_FECHA_MOV].getTime()) {
                    data[COL_FECHA_MOV] = fechaMov;
                }
                data[COL_VALOR_PAGADO] += valorPagadoEntero;
            }
        });
        
        const finalDataPagos = Array.from(aggregatedMap.values()).map(data => {
            return {
                [COL_DOC_PAGOS]: data[COL_DOC_PAGOS],
                [COL_MES_PAGOS]: data[COL_MES_PAGOS],
                [COL_FECHA_MAX_PAGOS]: formatDateToDDMMYYYY(data[COL_FECHA_MOV]), 
                [COL_VALOR_PAGADO]: data[COL_VALOR_PAGADO],
            };
        });
        
        dataFilePagos = finalDataPagos;

        // Guardado en Caché silencioso
        await saveDataToCache(CACHE_KEY_PAGOS, dataFilePagos);


        // MENSAJE FINAL SIMPLIFICADO
        pagosProcessStatus.textContent = `✅ Consolidación y Transformación de Pagos Completada.`;
        pagosProcessStatus.className = 'alert alert-success py-1';
        pagosStatus.textContent = `Data de Pagos lista. Ahora, cargue la Carpeta de Asignaciones (Paso 2).`;
        pagosStatus.className = 'alert alert-success py-1';

        // Si la data de Asignaciones ya está lista, iniciar el cruce
        if (processedDataAsignaciones) {
            executeMerge();
        }
    }

    // --- Lógica del Procesamiento de Asignaciones (Paso 2) (Igual que antes) ---

    function executeAsignacionesPreProcess() {
        if (!dataFileAsignaciones) return; 
        
        if (!dataFilePagos) {
            dedupeStatus.textContent = `⚠️ ERROR: Cargue la Carpeta de Pagos (Paso 1) primero.`;
            dedupeStatus.className = 'alert alert-danger py-1';
            dedupeStatus.style.display = 'block';
            return;
        }

        dedupeStatus.textContent = `⚙️ Iniciando limpieza y agregación de la data de Asignaciones...`;
        dedupeStatus.className = 'alert alert-warning py-1';
        dedupeStatus.style.display = 'block';
        downloadMergeBtn.style.display = 'none';

        setTimeout(() => {
            const docCol = COL_DOC_PRIN;
            const secAggCol = COL_MES_PRIN; 
            const minDateCol = COL_FECHA_PRIN; 
            const maxDateCol = COL_FECHA_PRIN; 
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); 
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const formattedYesterday = formatDateToDDMMYYYY(yesterday);
            const aggregatedMap = new Map();
            
            // --- AGRUPACIÓN Y AGREGACIÓN ---
            dataFileAsignaciones.forEach(row => {
                const docValue = String(row[docCol] || '').trim();
                const secAggValue = String(row[secAggCol] || '').trim(); 
                if (!docValue || !secAggValue) return; 
                const groupKey = `${docValue}|${secAggValue}`;
                
                const minDateValue = parseDate(row[minDateCol]);
                const maxDateValue = parseDate(row[maxDateCol]); 
                if (isNaN(minDateValue.getTime()) || isNaN(maxDateValue.getTime())) return; 
                
                if (!aggregatedMap.has(groupKey)) {
                    aggregatedMap.set(groupKey, { minDate: minDateValue, maxDate: maxDateValue, latestRow: {...row} });
                } else {
                    const data = aggregatedMap.get(groupKey);
                    if (minDateValue.getTime() < data.minDate.getTime()) data.minDate = minDateValue;
                    if (maxDateValue.getTime() >= data.maxDate.getTime()) {
                        data.maxDate = maxDateValue;
                        data.latestRow = {...row}; 
                    }
                }
            });
            
            let finalData = [];
            for (const data of aggregatedMap.values()) { 
                const finalRow = data.latestRow;
                const salidaDateStr = formatDateToDDMMYYYY(data.maxDate);
                finalRow['Ingreso'] = formatDateToDDMMYYYY(data.minDate);
                finalRow['Salida'] = salidaDateStr;
                finalRow['Estado Real'] = (salidaDateStr === formattedYesterday) ? 'ACTIVO' : 'INACTIVO';
                finalData.push(finalRow);
            }
            
            const dupCols = [docCol, secAggCol, COL_ANIO_PRIN].filter(v => v);
            let deduplicatedData = [];
            const seenKeys = new Set();
            
            if (dupCols.length > 0) {
                 finalData.forEach(row => {
                    const key = dupCols.map(col => String(row[col] || '').trim()).join('|'); 
                    if (!seenKeys.has(key)) {
                        seenKeys.add(key);
                        deduplicatedData.push(row);
                    }
                });
                finalData = deduplicatedData;
            }
            
            processedDataAsignaciones = finalData; 
            const finalRowCount = processedDataAsignaciones.length;
            dataFileAsignaciones = null; 
            
            dedupeStatus.textContent = `✅ Limpieza de data de Asignaciones completada. Filas finales: ${finalRowCount}.`;
            dedupeStatus.className = 'alert alert-info py-1';
            
            if (dataFilePagos) {
                executeMerge();
            }

        }, 50);
    }
    
    // --- EVENTOS DE CARGA ---

    // Evento 1: Carga de Carpeta de Pagos (Paso 1)
    pagosFolderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files).filter(file => file.size > 0 && (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')));
        if (files.length === 0) {
            pagosStatus.textContent = 'No se encontraron archivos CSV/TXT válidos en la carpeta.';
            pagosStatus.className = 'alert alert-danger py-1';
            return;
        }
        dataFilePagos = null; 
        executePagosProcess(files);
        downloadMergeBtn.style.display = 'none'; 
    });

    // Evento 2: Carga de Carpeta de Asignaciones (Paso 2)
    folderInput.addEventListener('change', async (event) => {
        const files = Array.from(event.target.files).filter(file => file.size > 0 && (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')));
        if (files.length === 0) {
            anexoStatus.textContent = 'No se encontraron archivos CSV/TXT válidos en la carpeta.';
            anexoStatus.className = 'alert alert-danger py-1';
            return;
        }

        anexoStatus.textContent = `Analizando ${files.length} archivos de Asignaciones...`;
        anexoStatus.className = 'alert alert-warning py-1';

        const allData = [];
        
        downloadMergeBtn.style.display = 'none';

        for (const file of files) {
            try {
                const results = await parseFile(file, true); 
                
                const match = file.name.match(/(\d{2}[-.]\d{2}[-.]\d{4})/); 
                let formattedDate = '01/01/1900'; 
                let month = '01';
                let year = '1900';
                
                if (match) {
                    const dateStr = match[0];
                    const parts = dateStr.match(/(\d{2})[-.](\d{2})[-.](\d{4})/);
                    if (parts && parts.length === 4) {
                        formattedDate = `${parts[1]}/${parts[2]}/${parts[3]}`; 
                        month = parts[2];
                        year = parts[3];
                    }
                }
                const monthFinal = parseInt(month, 10).toString(); 

                const processedRows = results.data.map(row => {
                    const newRow = {...row};
                    newRow[COL_FECHA_PRIN] = formattedDate; 
                    newRow[COL_MES_PRIN] = monthFinal; 
                    newRow[COL_ANIO_PRIN] = year; 
                    return newRow;
                });
                
                allData.push(...processedRows);

            } catch (e) {
                console.error(`Error al parsear archivo ${file.name}:`, e);
            }
        }
        
        if (allData.length > 0) {
            dataFileAsignaciones = allData; 
            anexoStatus.textContent = `¡Consolidación de Asignaciones lista! Iniciando limpieza automática...`;
            anexoStatus.className = 'alert alert-info py-1';
            
            executeAsignacionesPreProcess();

        } else {
            anexoStatus.textContent = 'No se encontraron archivos CSV/TXT válidos.';
            anexoStatus.className = 'alert alert-danger py-1';
        }
    });

</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</body>
</html>
