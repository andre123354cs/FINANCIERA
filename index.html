<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfama Financiera - YesBPO | Automatización Total (Secundario Primero)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body { background-color: #f4f7f6; }
        .container { max-width: 1400px; margin-top: 20px; background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .section-panel { padding: 15px; border: 1px solid #e0e0e0; border-radius: 0.25rem; margin-bottom: 20px; }
        .step-divider { border-top: 4px solid #0d6efd; margin-top: 30px; margin-bottom: 30px; padding-top: 15px; }
        h1 { color: #0d6efd; font-weight: 700; margin-bottom: 30px; }
        .section-title { font-size: 1.5rem; color: #495057; border-bottom: 2px solid #0d6efd; padding-bottom: 10px; margin-bottom: 20px; }
        /* Clases para ocultar elementos de configuración y filtros */
        .hidden-preview { display: none !important; }
        .hidden-filters select, .hidden-filters button { display: none !important; } 
    </style>
</head>
<body>

<div class="container">
    <h1 class="text-center">Comfama Financiera - YesBPO | Automatización Total de Datos 🚀</h1>

    <div id="cruceSection" class="section-panel">
        <div class="section-title text-success">1. Archivo Secundario (Carga Primero)</div>
        
        <p class="fw-bold">1.1 Carga de Archivo Secundario</p>
        <input type="file" class="form-control mb-3" id="file2Input" accept=".csv,.txt" required>
        <div class="alert alert-info py-1" id="file2Status">Cargue el archivo secundario (referencia) para continuar.</div>
        
        <div class="hidden-filters">
            <select id="col1Select" class="form-select"></select>
            <select id="col2Select" class="form-select"></select>
            <select id="col3Select" class="form-select"></select>
            <select id="col4Select" class="form-select"></select>
            <button id="executeMerge">REALIZAR CRUCE DE DATOS (LEFT JOIN)</button>
        </div>
        <div id="mergeResult" class="hidden-preview"></div>
    </div>
    
    <div class="section-panel step-divider">
        <div class="section-title">2. Archivo Principal: Consolidación y Limpieza (Automático)</div>
        
        <p class="fw-bold">2.1 Carga de Carpeta Principal</p>
        <input type="file" webkitdirectory directory multiple class="form-control mb-3" id="folderInput">
        <div class="alert alert-info py-1" id="anexoStatus">Cargue la carpeta con los archivos principales (consolidados).</div>
        
        <p class="fw-bold mt-4">2.2 Proceso Automático (Limpieza y Cruce)</p>
        
        <div class="alert alert-light mt-2 py-1" id="dedupeStatus" style="display:none;"></div>
        
        <div id="preProcessConfig" class="hidden-filters">
            <select id="docColSelect" class="form-select"></select>
            <select id="secAggColSelect" class="form-select"></select>
            <select id="minColSelect" class="form-select"></select>
            <select id="maxColSelect" class="form-select"></select>
            <select id="dupCol1Select" class="form-select"></select>
            <select id="dupCol2Select" class="form-select"></select>
            <select id="dupCol3Select" class="form-select"></select>
        </div>
        
        <div class="d-grid gap-2 d-md-flex justify-content-md-start mt-4">
            <button class="btn btn-primary btn-lg" onclick="downloadFile(processedData, 'consolidado_procesado.csv', '|');" id="downloadAnexoBtn" style="display:none;">
                Descargar Archivo Principal Limpio
            </button>
            <button class="btn btn-danger btn-lg" onclick="downloadFile(mergedData, 'resultado_cruce_final.csv', '|');" id="downloadMergeBtn" style="display:none;">
                Descargar Resultado Final del Cruce
            </button>
        </div>
        
    </div>
    
    <div id="pivotSection" class="hidden-preview"></div>

</div>

<script>
    // Variables globales
    let consolidatedData = null; 
    let processedData = null;    // Archivo Principal (Resultado del Paso 1)
    let dataFile2 = null;        // Archivo Secundario (Cargado en el Paso 1 visual)
    let mergedData = null;       // Resultado del Cruce (Paso 2)

    // Elementos del DOM
    const folderInput = document.getElementById('folderInput');
    const anexoStatus = document.getElementById('anexoStatus');
    const downloadAnexoBtn = document.getElementById('downloadAnexoBtn');
    const docColSelect = document.getElementById('docColSelect'); 
    const secAggColSelect = document.getElementById('secAggColSelect'); 
    const minColSelect = document.getElementById('minColSelect');
    const maxColSelect = document.getElementById('maxColSelect'); 
    const dupCol1Select = document.getElementById('dupCol1Select');
    const dupCol2Select = document.getElementById('dupCol2Select');
    const dupCol3Select = document.getElementById('dupCol3Select');
    const dedupeStatus = document.getElementById('dedupeStatus');
    const file2Input = document.getElementById('file2Input');
    const file2Status = document.getElementById('file2Status');
    const col1Select = document.getElementById('col1Select'); 
    const col2Select = document.getElementById('col2Select'); 
    const col3Select = document.getElementById('col3Select'); 
    const col4Select = document.getElementById('col4Select'); 
    const downloadMergeBtn = document.getElementById('downloadMergeBtn');
    
    // --- Definición de Nombres de Columnas para Automatización ---
    const COL_DOC_PRIN = 'Numero Documento';
    const COL_MES_PRIN = 'Mes data';
    const COL_FECHA_PRIN = 'Nombre del archivo';
    const COL_ANIO_PRIN = 'Año';
    const COL_DOC_SEC = 'Numero de Documento';
    const COL_MES_SEC = 'MES';

    // --- Funciones de Utilidad ---

    function parseFile(file, fastMode = false) {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                delimiter: "", 
                fastMode: fastMode, 
                complete: (results) => resolve(results),
                error: (error) => reject(error)
            });
        });
    }

    function downloadFile(data, filename, delimiter) {
        if (!data) {
            alert('No hay datos disponibles para descargar.');
            return;
        }
        const finalData = Array.isArray(data) ? data : data.data;
        const csv = Papa.unparse(finalData, { delimiter: delimiter, header: true });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    const parseDate = (dateString) => {
        if (!dateString) return new Date(0); 
        let dateParts = dateString.match(/(\d{1,2})[-./](\d{1,2})[-./](\d{4})/);
        if (dateParts) {
            const d = new Date(parseInt(dateParts[3]), parseInt(dateParts[2]) - 1, parseInt(dateParts[1]));
            if (!isNaN(d.getTime())) return d;
        } 
        dateParts = dateString.match(/(\d{4})-(\d{2})-(\d{2})/);
         if (dateParts) {
            const d = new Date(parseInt(dateParts[1]), parseInt(dateParts[2]) - 1, parseInt(dateParts[3]));
            if (!isNaN(d.getTime())) return d;
        } 
        return new Date(0); 
    };
    
    const formatDateToDDMMYYYY = (date) => {
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0'); 
        const year = d.getFullYear();
        return `${day}/${month}/${year}`;
    };

    function populateSelectors(fields, selectors, presets = {}) {
        selectors.forEach(select => {
            select.innerHTML = '';
            fields.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
            const presetValue = presets[select.id];
            if (presetValue && fields.includes(presetValue)) {
                select.value = presetValue;
            }
        });
    }

    function populateColumnSelectorsForMerge(fields1, fields2) {
        const selectors1 = [col1Select, col3Select];
        const selectors2 = [col2Select, col4Select];
        
        // 1. Archivo Principal (data1)
        selectors1.forEach(select => {
            const isKey1 = (select.id === 'col1Select');
            select.innerHTML = '';
            fields1.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
            if (isKey1 && fields1.includes(COL_DOC_PRIN)) {
                select.value = COL_DOC_PRIN;
            } else if (!isKey1 && fields1.includes(COL_MES_PRIN)) {
                select.value = COL_MES_PRIN;
            }
        });

        // 2. Archivo Secundario (data2)
        selectors2.forEach(select => {
            const isKey1 = (select.id === 'col2Select');
            select.innerHTML = '';
            fields2.forEach(field => {
                const option = document.createElement('option');
                option.value = field;
                option.textContent = field;
                select.appendChild(option);
            });
            if (isKey1 && fields2.includes(COL_DOC_SEC)) {
                select.value = COL_DOC_SEC;
            } else if (!isKey1 && fields2.includes(COL_MES_SEC)) {
                select.value = COL_MES_SEC;
            } else if (isKey1 && fields2.includes(COL_DOC_PRIN)) {
                select.value = COL_DOC_PRIN;
            }
        });
    }

    // --- FUNCIÓN DE CRUCE (Se llama al final) ---
    function executeMerge() {
        if (!processedData || !dataFile2) {
            // Esto no debería pasar si se llama correctamente
            return;
        }

        // Obtener la configuración de las columnas clave (automáticamente asignadas)
        const key1_A = col1Select.value; 
        const key1_B = col2Select.value; 
        const key2_A = col3Select.value; 
        const key2_B = col4Select.value; 
        
        if (!key1_A || !key1_B) {
            dedupeStatus.textContent = 'ERROR: No se pudo configurar el cruce. Revise los nombres de columnas clave.';
            dedupeStatus.className = 'alert alert-danger py-1';
            return;
        }
        const useKey2 = key2_A && key2_B;

        dedupeStatus.textContent = '🚀 CRUCE DE DATOS AUTOMÁTICO EN CURSO... Por favor, espere.';
        dedupeStatus.className = 'alert alert-warning py-1';
        downloadMergeBtn.style.display = 'none'; 

        setTimeout(() => {
            
            const data1 = processedData;
            const data2 = dataFile2.data;
            // Headers del archivo secundario que NO son la clave de cruce
            const headers2 = dataFile2.meta.fields.filter(h => h !== key1_B && (!useKey2 || h !== key2_B));

            // 1. Crear el mapa de búsqueda (data2)
            const map2 = new Map();
            data2.forEach(row => {
                let keyValue = String(row[key1_B] || '').trim();
                if (useKey2) keyValue += `|${String(row[key2_B] || '').trim()}`;
                
                if (keyValue) {
                    const rowData = {};
                    headers2.forEach(field => rowData[field] = row[field]);
                    if (!map2.has(keyValue)) map2.set(keyValue, []);
                    map2.get(keyValue).push(rowData);
                }
            });
            
            dataFile2 = null; 

            // 2. Realizar el LEFT JOIN (data1)
            const mergedResults = [];
            
            data1.forEach(row1 => {
                let searchKey = String(row1[key1_A] || '').trim();
                if (useKey2) searchKey += `|${String(row1[key2_A] || '').trim()}`;

                const matchingRows2 = map2.has(searchKey) ? map2.get(searchKey) : [{}];
                
                matchingRows2.forEach(row2Data => {
                    const newRow = { ...row1 }; 
                    let isMatch = Object.keys(row2Data).length > 0;
                    
                    for (const field of headers2) {
                        const newFieldName = Object.prototype.hasOwnProperty.call(newRow, field) ? `${field}_Arch2` : field;
                        newRow[newFieldName] = isMatch ? row2Data[field] : ''; 
                    }
                    mergedResults.push(newRow);
                });
            });

            mergedData = mergedResults;
            
            if (mergedData.length > 0) {
                dedupeStatus.textContent = `✅ **PROCESO FINALIZADO**. El resultado tiene **${mergedData.length}** filas. Descargue los archivos.`;
                dedupeStatus.className = 'alert alert-success py-1';
                downloadMergeBtn.style.display = 'block'; 
            } else {
                dedupeStatus.textContent = `⚠️ Error: El cruce no generó resultados válidos.`;
                dedupeStatus.className = 'alert alert-danger py-1';
            }
            
            // Liberar memoria
            processedData = null;

        }, 50); 
    }

    // --- FUNCIÓN DE PROCESAMIENTO INICIAL (Paso 1) ---
    function executePreProcess() {
        if (!consolidatedData) return; 

        // 1. Mostrar estado de procesamiento
        dedupeStatus.textContent = `⚙️ Iniciando limpieza y agregación de la data principal...`;
        dedupeStatus.className = 'alert alert-warning py-1';
        dedupeStatus.style.display = 'block';
        downloadAnexoBtn.style.display = 'none';
        downloadMergeBtn.style.display = 'none';

        setTimeout(() => {
            const docCol = docColSelect.value;
            const secAggCol = secAggColSelect.value; 
            const minDateCol = minColSelect.value; 
            const maxDateCol = maxColSelect.value; 

            if (!docCol || !secAggCol || !minDateCol || !maxDateCol) {
                 dedupeStatus.textContent = '❌ Error de Configuración: Las columnas clave del Consolidado no se encontraron.';
                 dedupeStatus.className = 'alert alert-danger py-1';
                 return;
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); 
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const formattedYesterday = formatDateToDDMMYYYY(yesterday);
            const aggregatedMap = new Map();
            
            // --- AGRUPACIÓN Y AGREGACIÓN ---
            consolidatedData.forEach(row => {
                const docValue = String(row[docCol] || '').trim();
                const secAggValue = String(row[secAggCol] || '').trim(); 
                if (!docValue || !secAggValue) return; 
                const groupKey = `${docValue}|${secAggValue}`;
                
                const minDateValue = parseDate(row[minDateCol]);
                const maxDateValue = parseDate(row[maxDateCol]);
                if (isNaN(minDateValue.getTime()) || isNaN(maxDateValue.getTime())) return; 
                
                if (!aggregatedMap.has(groupKey)) {
                    aggregatedMap.set(groupKey, { minDate: minDateValue, maxDate: maxDateValue, latestRow: {...row} });
                } else {
                    const data = aggregatedMap.get(groupKey);
                    if (minDateValue.getTime() < data.minDate.getTime()) data.minDate = minDateValue;
                    if (maxDateValue.getTime() >= data.maxDate.getTime()) {
                        data.maxDate = maxDateValue;
                        data.latestRow = {...row}; 
                    }
                }
            });
            
            let finalData = [];
            for (const data of aggregatedMap.values()) { 
                const finalRow = data.latestRow;
                const salidaDateStr = formatDateToDDMMYYYY(data.maxDate);
                finalRow['Ingreso'] = formatDateToDDMMYYYY(data.minDate);
                finalRow['Salida'] = salidaDateStr;
                finalRow['Estado Real'] = (salidaDateStr === formattedYesterday) ? 'ACTIVO' : 'INACTIVO';
                finalData.push(finalRow);
            }
            
            // --- DEDUPLICACIÓN FINAL ---
            const dupCols = [docCol, secAggCol, dupCol1Select.value, dupCol2Select.value, dupCol3Select.value].filter(v => v);
            let deduplicatedData = [];
            const seenKeys = new Set();
            
            if (dupCols.length > 0) {
                 finalData.forEach(row => {
                    const key = dupCols.map(col => String(row[col] || '').trim()).join('|'); 
                    if (!seenKeys.has(key)) {
                        seenKeys.add(key);
                        deduplicatedData.push(row);
                    }
                });
                finalData = deduplicatedData;
            }
            
            processedData = finalData; 
            const finalRowCount = processedData.length;
            consolidatedData = null; 
            
            // Actualizar UI
            dedupeStatus.textContent = `✅ Limpieza de data principal completada. Filas finales: ${finalRowCount}.`;
            dedupeStatus.className = 'alert alert-success py-1';
            downloadAnexoBtn.style.display = 'block';
            
            // Preparar selectores para el Paso 2
            if (processedData.length > 0) {
                const consolidatedHeaders = Object.keys(processedData[0]);
                
                // Si el archivo secundario ya está cargado, ¡ejecutar el cruce de inmediato!
                if (dataFile2) {
                    const fields2 = dataFile2.meta.fields;
                    populateColumnSelectorsForMerge(consolidatedHeaders, fields2);
                    executeMerge();
                } else {
                    // Si no, solo actualizamos el selector por si se carga después
                    populateColumnSelectorsForMerge(consolidatedHeaders, []);
                }
            }

        }, 50);
    }
    
    // --- EVENTOS DE CARGA (Orden Invertido) ---

    // Evento 1: Carga de Archivo Secundario
    file2Input.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        file2Status.textContent = `Analizando archivo secundario ${file.name}...`;

        try {
            const data = await parseFile(file, true); 
            const headers2 = data.meta.fields;
            let rawData2 = data.data;
            
            // Transformación a string para las claves de cruce
            if (rawData2.length > 0) {
                const transformedData2 = rawData2.map(row => {
                    const newRow = { ...row };
                    if (headers2.includes(COL_DOC_SEC) && row[COL_DOC_SEC] !== undefined) newRow[COL_DOC_SEC] = String(row[COL_DOC_SEC]);
                    if (headers2.includes(COL_MES_SEC) && row[COL_MES_SEC] !== undefined) newRow[COL_MES_SEC] = String(row[COL_MES_SEC]);
                    return newRow;
                });
                dataFile2 = { data: transformedData2, meta: data.meta }; 
            } else {
                dataFile2 = data;
            }
            
            file2Status.textContent = `✅ Archivo secundario cargado y listo. Fila: ${dataFile2.data.length}. Ahora cargue la carpeta principal.`;
            file2Status.className = 'alert alert-success py-1';
            
            // Si el Archivo Principal ya está procesado (se cargó antes por error), ejecutar el cruce
            if (processedData) {
                const fields1 = Object.keys(processedData[0]);
                populateColumnSelectorsForMerge(fields1, headers2);
                executeMerge();
            }
            
        } catch (error) {
            file2Status.className = 'alert alert-danger py-1';
            file2Status.textContent = `Error al cargar: ${error.message}`;
            dataFile2 = null;
        }
    });

    // Evento 2: Carga de Carpeta Principal
    folderInput.addEventListener('change', async (event) => {
        const files = event.target.files;
        if (files.length === 0) return;

        anexoStatus.textContent = `Analizando ${files.length} archivos...`;
        anexoStatus.className = 'alert alert-warning py-1';

        const allData = [];
        let fileCount = 0;
        let headers = new Set();
        
        // Resetear descargas anteriores
        downloadMergeBtn.style.display = 'none';

        for (const file of files) {
            if (!file.name.toLowerCase().endsWith('.csv') && !file.name.toLowerCase().endsWith('.txt')) continue;
            try {
                const results = await parseFile(file, true); 
                
                const match = file.name.match(/(\d{2}[-.]\d{2}[-.]\d{4})/); 
                let formattedDate = '01/01/1900'; 
                let month = '01';
                let year = '1900';
                
                if (match) {
                    const dateStr = match[0];
                    const parts = dateStr.match(/(\d{2})[-.](\d{2})[-.](\d{4})/);
                    
                    if (parts && parts.length === 4) {
                        formattedDate = `${parts[1]}/${parts[2]}/${parts[3]}`; 
                        month = parts[2];
                        year = parts[3];
                    }
                }
                const monthFinal = parseInt(month, 10).toString(); 

                const processedRows = results.data.map(row => {
                    const newRow = {...row};
                    newRow[COL_FECHA_PRIN] = formattedDate; 
                    newRow[COL_MES_PRIN] = monthFinal; 
                    newRow[COL_ANIO_PRIN] = year; 
                    return newRow;
                });
                
                allData.push(...processedRows);
                processedRows.forEach(row => Object.keys(row).forEach(header => headers.add(header)));
                fileCount++;

            } catch (e) {
                console.error(`Error al parsear archivo ${file.name}:`, e);
            }
        }
        
        if (allData.length > 0) {
            consolidatedData = allData; 
            anexoStatus.textContent = `¡Consolidación de archivos exitosa! ${fileCount} archivos cargados. Iniciando limpieza...`;
            anexoStatus.className = 'alert alert-info py-1';
            
            // Configurar Selectores Ocultos
            const headersArray = Array.from(headers);
            const presets = {
                'docColSelect': COL_DOC_PRIN, 'secAggColSelect': COL_MES_PRIN,
                'minColSelect': COL_FECHA_PRIN, 'maxColSelect': COL_FECHA_PRIN, 
                'dupCol1Select': COL_DOC_PRIN, 'dupCol2Select': COL_MES_PRIN, 'dupCol3Select': COL_ANIO_PRIN
            };
            const preProcessSelectors = [docColSelect, secAggColSelect, minColSelect, maxColSelect, dupCol1Select, dupCol2Select, dupCol3Select];
            populateSelectors(headersArray, preProcessSelectors, presets);
            
            // *** LLAMADA AUTOMÁTICA AL PROCESAMIENTO (Limpieza y luego Cruce) ***
            executePreProcess();

        } else {
            anexoStatus.textContent = 'No se encontraron archivos CSV/TXT válidos.';
            anexoStatus.className = 'alert alert-danger py-1';
            downloadAnexoBtn.style.display = 'none';
        }
    });

</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

</body>
</html>
